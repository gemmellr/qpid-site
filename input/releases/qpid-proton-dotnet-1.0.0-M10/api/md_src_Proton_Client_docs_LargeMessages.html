<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Proton DotNet: Sending and Receiving large messages with proton-dotnet</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Proton DotNet
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Sending and Receiving large messages with proton-dotnet </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>When sending and receiving messages whose size exceeds what might otherwise be acceptable to having in memory all at once the proton-dotnet client has a flexible API to make this process simpler. The stream sender and stream receiver APIs in the proton-dotnet client offer the ability to read and write messages in manageable chunks that prevent application memory being exhausted trying to house the entire message. This API also provides a simple means of streaming files directly vs having to write a large amount of application code to perform such operations.</p>
<h1><a class="anchor" id="autotoc_md29"></a>
Stream senders and receivers</h1>
<p>The API for handling large message is broken out into stream senders and stream receivers that behave a bit differently than the standard senders and receivers. Unlike the standard sender and receiver which operate on whole in memory messages the streaming API makes message content available through stream where bytes can be read or written in chunks without the need to have to entire contents in memory at once. Also the underlying streaming implementation performs tight flow control to prevent the remote from sending to much before the local side has processed it, and sender blocks send operations when necessary to wait for capacity to send pending bytes to the remote.</p>
<h1><a class="anchor" id="autotoc_md30"></a>
Using the stream sender</h1>
<p>To send a large message using the stream sender API you need to create a <code>IStreamSender</code> type which operates similar to the normal Sender API but imposes some restrictions on usage compared to the normal Sender. Creating the stream sender is shown below:</p>
<div class="fragment"><div class="line">IStreamSender sender = connection.OpenStreamSender(address)</div>
</div><!-- fragment --><p>This code opens a new stream sender for the given address and returns a <code>IStreamSender</code> type which you can then use to obtain the streaming message type which you will use to write the outgoing bytes. Unlike the standard message type the streaming message is created from the sender and it tied directly to that sender instance, and only one streaming message can be active on a sender at any give time. To create an outbound stream message use the following code:</p>
<div class="fragment"><div class="line">IStreamSenderMessage message = sender.BeginMessage();</div>
</div><!-- fragment --><p>This requests that the sender initiate a new outbound streaming message and will throw an exception if another stream sender message is still active. The <code>IStreamSenderMessage</code> is a specialized <code>IMessage</code> type whose body is an output stream type meaning that it behaves much like a normal message only the application must get a reference to the body output stream to write the outgoing bytes. The code below shows how this can be done in practice.</p>
<div class="fragment"><div class="line">message.Durable = true;</div>
<div class="line">message.SetAnnotation(&quot;x-opt-annotation&quot;, &quot;value&quot;);</div>
<div class="line">message.SetProperty(&quot;application-property&quot;, &quot;value&quot;);</div>
<div class="line"> </div>
<div class="line">// Creates an OutputStream that writes a single Data Section whose expected</div>
<div class="line">// size is configured in the stream options.</div>
<div class="line">OutputStreamOptions streamOptions = new()</div>
<div class="line">{</div>
<div class="line">   BodyLength = buffer.Length</div>
<div class="line">};</div>
<div class="line">Stream output = message.GetBodyStream(streamOptions);</div>
<div class="line"> </div>
<div class="line">while (&lt;has data to send&gt;)</div>
<div class="line">{</div>
<div class="line">    output.Write(buffer, i, chunkSize);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">output.Close();  // This completes the message send.</div>
<div class="line"> </div>
<div class="line">message.Tracker().AwaitAccepted();</div>
</div><!-- fragment --><p>In the example above the application code has already obtained a stream sender message and uses it much like a normal message, setting application properties and annotations for the receiver to interpret and then begins writing from some data source a stream of bytes that will be encoded into an AMQP <code>Data</code> section as the body of the message, the sender will ensure that the writes occur in manageable chunks and will not retain the previously written bytes in memory. A write call the the message body output stream can block if the sender is waiting on additional capacity to send or on IO level back-pressure to ease.</p>
<p>Once the application has written all the payload into the message it completes the operation by closing the <code>Stream</code> and then it can await settlement from the remote to indicate the message was received and processed successfully.</p>
<h2><a class="anchor" id="autotoc_md31"></a>
Sending a large file using the stream sender</h2>
<p>Sending a file using the <code>IStreamSenderMessage</code> is an ideal use case for the stream sender. The first thing the application would need to do is to validate a file exists and open it (this is omitted here). Once a file has been opened the following code can be used to stream to contents to the remote peer.</p>
<div class="fragment"><div class="line">using IConnection connection = client.Connect(serverHost, serverPort, options);</div>
<div class="line">using IStreamSender sender = connection.OpenStreamSender(address);</div>
<div class="line">using FileStream inputStream = File.OpenRead(fileName);</div>
<div class="line"> </div>
<div class="line">IStreamSenderMessage message = sender.BeginMessage();</div>
<div class="line"> </div>
<div class="line">// Application can inform the other side what the original file name was.</div>
<div class="line">message.SetProperty(fileNameKey, filename);</div>
<div class="line"> </div>
<div class="line">try</div>
<div class="line">{</div>
<div class="line">   using Stream output = message.Body;</div>
<div class="line">   inputStream.CopyTo(output);</div>
<div class="line">}</div>
<div class="line">catch (Exception)</div>
<div class="line">{</div>
<div class="line">   message.Abort();</div>
<div class="line">}</div>
</div><!-- fragment --><p>In the example above the code makes use the .NET API from the <code>Stream</code> class to transfer the contents of a file to the remote peer, the transfer API will read the contents of the file in small chunks and write those into the provided <code>Stream</code> which in this case is the stream from our <code>IStreamSenderMessage</code>.</p>
<h1><a class="anchor" id="autotoc_md32"></a>
Using the stream receiver</h1>
<p>To receive a large message using the stream receiver API you need to create a <code>IStreamReceiver</code> type which operates similar to the normal Receiver API but imposes some restrictions on usage compared to the normal Sender. Creating the stream receiver is shown below:</p>
<div class="fragment"><div class="line">IStreamReceiver receiver = connection.OpenStreamReceiver(address));</div>
</div><!-- fragment --><p>This code opens a new stream receiver for the given address and returns a <code>IStreamReceiver</code> type which you can then use to obtain the streaming message type which you will use to read the incoming bytes. Just like the standard message type the streaming message is received from the receiver instance but and it is tied directly to that receiver as it read incoming bytes from the remote peer, therefore only one streaming message can be active on a receiver at any give time. To create an inbound stream message use the following code:</p>
<div class="fragment"><div class="line">IStreamDelivery delivery = receiver.Receive();</div>
<div class="line">IStreamReceiverMessage message = delivery.Message();</div>
</div><!-- fragment --><p>Once a new inbound streaming message has been received the application can read the bytes by requesting the <code>Stream</code> from the message body and reading from it as one would any other input stream scenario.</p>
<div class="fragment"><div class="line">Stream inputStream = message.Body;</div>
<div class="line"> </div>
<div class="line">byte[] chunk = new byte[10];</div>
<div class="line">int readCount = 0;</div>
<div class="line"> </div>
<div class="line">while (inputStream.Read(chunk) != 0)</div>
<div class="line">{</div>
<div class="line">   Console.WriteLine(string.Format(&quot;Read data chunk [{0:D2}]: size =&gt; {1}&quot;, ++readCount, chunk.Length));</div>
<div class="line">}</div>
</div><!-- fragment --><p>In the example code above the application reads from the message body input stream and simply writes out small chunks of the body to the system console, the read calls might block while waiting for bytes to arrive from the remote but the application remains unaffected in this case.</p>
<h2><a class="anchor" id="autotoc_md33"></a>
Receiving a large file using the stream receiver</h2>
<p>Just as stream sending example from previously sent a large file using the <code>IStreamSenderMessage</code> an application can receive and write a large message directly into a file with a few quick lines of code. An example follows which shows how this can be done, the application is responsible for choosing a proper location for the file and verifying that it has write access.</p>
<div class="fragment"><div class="line">using IConnection connection = client.Connect(serverHost, serverPort, options);</div>
<div class="line">using IStreamReceiver receiver = connection.OpenStreamReceiver(address);</div>
<div class="line"> </div>
<div class="line">IStreamDelivery delivery = receiver.Receive();</div>
<div class="line">IStreamReceiverMessage message = delivery.Message();</div>
<div class="line">Stream inputStream = message.Body;</div>
<div class="line"> </div>
<div class="line">// Application needs to define where the file should go</div>
<div class="line">using FileStream outputStream = File.Create(outputLocation);</div>
<div class="line"> </div>
<div class="line">message.Body.CopyTo(outputStream);</div>
</div><!-- fragment --><p>Just as in the stream sender case the application can make use of the .NET transfer API for <code>Stream</code> instances to handle the bulk of the work reading small blocks of bytes and writing them into the target file, in most cases the application should add more error handling code not shown in the example. Reading from the incoming byte stream can block waiting for data from the remote which may need to be accounted for in some applications. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
